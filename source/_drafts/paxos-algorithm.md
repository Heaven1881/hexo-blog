---
title: Paxos算法简易教程
tags:
  - paxos
  - 分布式
  - 一致性
categories:
  - 分布式架构
---

Paxos是一个非常有名的一致性算法，其目的是为在网络中的各个进程提供信息同步的方法。之前对Paxos的了解一直很模糊，前段时间认真的把相关的论文看了一遍，总算才理解了Paxos的主要思想。现在特地记录下来。

<!-- more -->

# 前言
关于Paxos的详细介绍，可以参考这篇论文：[Paxos Made Simple by Lamport](http://research.microsoft.com/en-us/um/people/lamport/pubs/paxos-simple.pdf)。

对Paxos算法有一定了解的人一定会知道Paxos算法里面有Proposer，Acceptor和Learner三种角色。但这篇文章不会从这三个角度切入，我会按照我自己的理解和思路来介绍这个算法，如果看了很多相关文章但是仍是对Paxos一知半解，不如换一个角度了解Paxos算法，也许你的思路会豁然开朗。

# 问题背景
首先Paxos算法的目的就是要保证通过网络连接的多台机器之间数据的一致性。很多互联网公司(例如淘宝和京东)都需要24小时不间断的对外提供服务，这就要求其对应的数据库服务也必须24小时不间断的提供服务，但是对于单台机器来说这是不可能的，因为世界上没有一台机器可以保证永远不会宕机，而且也不能保证其对外服务的网络永远不出问题，大多数情况下，让一台机器恢复正常的时间很有可能需要数个小时甚至数天，因此，这些互联网公司需要在不同的网络部署多台机器，以便在其中一台机器出问题时，其他的机器仍然可以提供服务。这也就是我们现在经常听到的分布式结构。

<!-- 这里添加一张多个服务器同时服务的示例图 -->

分布式结构固然有很多优点，但是也带来了很多问题，其中一个问题就是如何维持不同节点之间的数据一致性。

我们先来简单解释一下为什么要保证不同节点之间的一致性。因为我们使用分布式的目的就是希望在一台机器出现问题时，尽快地将流量切换到另一台，因此两台机器上的数据必须时刻保持一致，否则在切换机器时会造成数据丢失。

那么如何保证分布式架构的一致性呢？这就是Paxos算法需要做的事情了。

# 强一致性算法

Paxos算法是非常经典的分布式一致性算法，它的目标是保持分布式结构的强一致性。

> **关于强一致性与最终一致性？**
> 目前业界对一致性的界定主要分为强一致性与最终一致性。强一致性要求所有节点任意时刻的数据都是完全一致的，而最终一致性不要求节点数据时刻保持一致，只要保证各个节点的数据最终是一致的即可。

假设有$n$台机器负责数据库服务，在初始的时候所有机器上的数据库都是空的，现在我们需要保证我在任意一个机器上做的数据操作都能同步到其他机器上。也就是说，所有的机器要同时收到并执行我的数据操作指令(在这里，我们不妨假设操作数据库的指令就是是SQL命令)。我们可以发现，因为每个机器初始的数据状态是一致的，只要他们执行的指令序列完全相同，那么他们数据状态仍然是一致的。

<!-- 插图：展现通过指令队列计算当前数据状态的例子 -->

现在，为了保证各个节点的数据一致，我们只需要保证每个节点上操作数据的命令是一致的即可。为了更简单的介绍Paxos算法，我们接下来假设有一个Client节点和若干个Server节点，Server节点就是我们的数据库节点，Client节点的主要工作就是要对Server节点负责的数据库进行读写操作(这里我们只考虑写操作，因为读操作不会破坏节点的一致性)。需要注意的是，Server节点的数量最少为3，我们会在下面介绍具体原因。

<!-- 配图：一个Client节点和若干个Server节点 -->

要保证每个节点执行命令序列的一致，我们只需要了解如何保证其中一条命令的一致性。例如，现在Client节点需要向Server节点提交第$m$条命令。假设当前状态下，所有的Server节点都已经知道第1条命令到第$m-1$条命令的内容了，那么在Paxos中，第$m$条命令会经历两个阶段：

- 提交阶段
- 应用阶段

## 提议阶段

<!--配图：Client节点向所有Server节点提议第m条命令-->

在这个阶段，Client所要做的就是向每个Server提议第$m$条命令，注意这里使用了“提议”这个词，英文就是proposal，这个词代表Server节点并不一定会介绍客户端的提议，每个Server节点是否要接受客户端的提议和Server自己的状态有关。例如，Server会无条件拒绝客户端修改前面$m-1$条命令的提议，不过在这里，Client要修改的是第$m$条命令，我们暂时假设所有的Server都会接受这个请求。

在Client向Server发送的提议中，除了包括命令的内容，还会额外添加一个额外编号，在这里我们把这个编号称作**提议编号**。**提议编号**主要用于区分不同的提议，因为Paxos算法允许任意多的Client同时向Server集群提议，同时提议编号是全局唯一并且递增的，无论有多少个Client，对于第$m$条命令，每个Client使用的提议编号都是不同的，并且使用的提议编号随时间递增。(关于全局唯一递增ID，有很多可行的实现方法，这里我不做具体介绍，只需要假设它是存在的即可)

### Server节点
当Client向其中一个Server“提议”时，Server可以有以下几种返回：

- 如果Client尝试修改第$k$条命令$(k < m)$，那么Server会拒绝这个**提议**，并告诉Client：“第k条命令已经确定并且无法更改，这条命令的内容是...”
- 如果Server曾经接受了其它Client的提议，那么它会检查这个提议的**提议编号**：
 - 如果编号大于等于Server曾经接受的**提议编号**，那么Server就会接受这个提议，同时将自己接受的提议编号修改为新的数值。
 - 如果编号小于Server曾经接受的**提议编号**，那么Server就会拒绝这个提议，并告诉Client拒绝原因：“对于第k条命令，你的提议已经过时了”。
- 在其他情况下，Server都会接受Client的提议。

### Client节点
我们假设Client尝试向Server集群提议第$k$条命令，那么Client需要做的就是向所有的Server节点发送提议，由于每个Server状态不一定相同，因此并不是所有的Server都会接受这个提议。但是对于Client来说，只要超过一半的Server节点接受提议就可以了。

这也就解释了为什么我们在上面提到Server集群的数量最少为3了。因为对于节点数为1或者2的集群来说，“超过一半”和“全部”的概念是一样的。

对于不同Server的回应，Client可以有以下几种反应：

- 如果Client收到Server回复说“第k条命令已经确定并且无法更改，这条命令的内容是...”，那么Client就放弃当前的提议，直接结束。
- 如果Client收到Server回复说“对于第k条命令，你的提议已经过时了”，那么Client既可以放弃提议，也可以申请新的提议编号重新向每一个Server端发起新的提议。
- 如果接受提议的Server没有超过一半，那么Client既可以放弃提议，也可以申请新的提议编号重新向每一个Server端发起新的提议。
- 如果超过一半的Server接受了Client的提议，那么Client就可以进入下一个阶段了(应用阶段)

> 大家可能会发现，对于上面提到的Client的几种回应中，如果有两个Client同时进行提议操作，那么很可能会导致谁的提议都无法通过。两个Client在提议被拒绝后都申请新的提议编号重新提议，最后提议编号越来越大并且谁也无法获得超过半数的Server支持。关于这个问题，我们会在下面详细解释。

## 应用阶段

如果Client收到了超过半数的Server节点的确认消息，那么就可以一一通知Server来确认这次命令了。对于Paxos来说，只要有超过半数的Server接受了某个命令，我们就认为在当前集群的一致性就可以初步得到保证了。

假设在提议阶段，Client收到了$n$个Server节点的确认$(n>m/2)$，那么在应用阶段，Client就会一次通知每个确认的Server：“我已经收到了大多数Server的确认，请把第m条命令应用为...”。

### Server节点
不过，在这个阶段，Server节点也不一定会真正接受Client的应用请求。Server一般有以下两种种回复请求：

- 如果Server在等待Client的应用请求时，正好又有另一个Client发起了新的提议，如果这个提议的编号大于Server准备要接受的编号，那么Server就会抛弃旧的提议而接受新的提议。在这种情况下，当第一个Client发来应用请求时，Server发现这个应用请求并不是自己最新接受的，那么Server会拒绝这个应用请求：“对于第k条命令，你的提议已经过时了，我已经有更好的选择”
- 如果一切正常，Server会接受Client的应用请求。

### Client节点
如果Client成功通知了所有Server，那么就已经完成了所有的过程，如果Client不幸地发现有Server像上面提到的一样拒绝了它，那么它可能会有以下几种行动：

- 成功应用的Server总数仍然超过半数，那么这次应用请求仍然是成功的。Client已经成功让半数的Server节点接受了它的提议。
- 成功应用的Server总数不足一半(这里需要研究一下)

# Paxos如何保持一致性

<!-- 多个Client节点 -->

<!-- Server节点从宕机回复 -->

<!-- Server节点的学习行为-->



---
> 本文欢迎转载，但是希望注明出处并给出原文链接。
> 如果你有任何疑问，欢迎在下方评论区留言，我会尽快答复。
> 如果你喜欢或者不喜欢这篇文章，欢迎你发邮件到[winton.luo@outlook.com](mailto:winton.luo@outlook.com)告诉我你的想法，你的建议对我非常重要。